## 1. 插入排序
- **基本思想：**
	- 每一趟将待排序的记录，按照其关键字的大小插入到已经排好序的一组记录的适当位置上，直到所有的待排序记录全部插入为止。
- **算法特点：**
  - 稳定排序
  - 算法简便，且容易实现
  - 也适用于链式存储结构，只是单链表上无需移动记录，只需要修改相应指针。
  - 更适用于初始记录基本有序的情况，当初始记录无序，N较大时，次算法的时间复杂度较高不宜采用。
- **思路：**
```txt
假若时按升序排序：
1. 遍历整个序列，获得当前待排序元素
2. data[i]与data[i-1]到data[0]逐个比较
3. 找到一个合适的位置j， 将第j到i-1的元素同时向后移动一个位置，并在位置j插入当前元素
4. 返回第一步，继续遍历下一个元素
```
- **伪代码**
```cpp
insertionSort(data[], n)
	for i=1到i=n-1
		将大于data[i]的所有元素data[j]都移动一个位置，然后将data[i]放在合适的位置。
```
- **示例代码**
```cpp
//插入排序
template <typename T>
void insertSort(T data[], int n, bool opt)
{
    T temp;
    for (int i = 1, pos; i < n; i++)
    {
        temp = data[i];
        if (opt == true) //升序
        {
            for (pos = i; pos > 0 && temp < data[pos - 1]; pos--)
            { 
                data[pos] = data[pos - 1];
            }
        }
        else //降序
        {
            for (pos = i; pos > 0 && temp > data[pos - 1]; pos--)
            {
                data[pos] = data[pos - 1];
            }
        }

        data[pos] = temp;
    }
}
```
- **时间复杂度计算**

  最好情况下是O(n)，最坏情况是$O(n^2)$ , 而平均情况是$O(\frac{n^2}{2})$。最坏情况是平均情况的两倍时间复杂度，如果序列长度增加一倍，那么最坏情况下消耗的时间将是平均情况下的四倍。所以插入算法不适用于大量数据的排序。

**①、最好情况$O({n}) = 3(n-1)$：**

*比较次数* ：   因为有序，所以每一趟遍历只需要比较一次，总的为：n-1次比较

*移动次数* ：   每次循环temp的加载和卸载次数为2次，总的为2(n-1)次，因为内层循环没有发生元素移动，所以内层循环移动次数为0，总移动次数为：2(n-1)次。

*总执行次数*  :  比较次数+移动次数 = $(n-1)+2(n-1) = 3(n-1)$

*复杂度* ：$O(n)$

**②、最坏情况$O({n}^2) = n^2 +n -2$ ：**

*比较次数* ：在n-1次遍历中，因为序列逆序，所以第一个元素需要比较1次，第二个元素需要比较2次... 第n-1个元素需要比较n-1次。所以对所有的比较次数进行累加：$1+2+...+n-1 =  \frac{n(n-1)}{2}$ 。

*移动次数* ：内层循环元素移动次数为：$1+2+...+n-1 =  \frac{n(n-1)}{2}$ , tmp的加载卸载总次数为2(n-1)。所以总的移动次数为$\frac{n(n-1)}{2} + 2(n-1) =\frac{{n}^2+3n-4}{2}$

*总的执行次数* ： $\frac{n(n-1)}{2}+\frac{n(n-1)}{2} + 2(n-1) = {n}^2 + n -2$ 

*复杂度* ：$O(n^2)$

**③、平均情况$O({n}^2)$：**

*平均比较次数*：在第i趟排序总，插入的位置可能时0 -->（i-1）中的任何一个位置，所以这一趟的平均比较次数为：$\frac{(1+2+...+i)}{i} = \frac{\frac{1}{2}i(i+1)}{i} = \frac{i+1}{2}$ 。

总的比较次数$\sum_{1}^{n-1} \frac{i+1}{2} = \frac{1}{2}\sum_1^{n-1}i +\sum_1^{n-1}\frac{1}{2} = \frac{n^2+n-2}{4}$

*平均移动次数*：temp的加载和卸载为：2(n-1)次； 移动次数为：$2(n-1) + \frac{n^2+n-2}{4} = \frac{n^2+9n-10}{4}$

*平均执行次数*：平均比较次数+ 移动次数 = $\frac{n^2+n-2}{4}+\frac{n^2+9n-10}{4} = \frac{n^2+5n-6}{2}$

*时间复杂度* ： $O(n^2) = \frac{n^2+5n-6}{2}$

- **空间复杂度**：$O(1)$
